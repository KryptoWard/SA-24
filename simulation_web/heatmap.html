<!DOCTYPE html>
<!--
  Coverage heatmap page that visualizes sensor
  performance using real or simulated data.
  It shades the room according to detection
  accuracy so weak areas can be identified.
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SA√â24 - Heatmap de Couverture</title>
    <link rel="stylesheet" href="styles.css">

    <style>
        .controls-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 500;
            color: #5a6c7d;
            font-size: 0.9rem;
        }

        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1rem;
            background-color: #f8f9fa;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .heatmap-container, .info-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }

        .heatmap-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.3rem;
            color: #2c3e50;
            font-weight: 600;
        }

        .heatmap-canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .legend {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 0 10px;
            font-size: 0.8rem;
            color: #5a6c7d;
        }

        .info-panel {
            grid-column: 1 / -1;
        }
        
        .info-panel h3 {
            text-align: center;
            font-size: 1.5rem;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #5a6c7d;
        }

        @media (max-width: 900px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="container nav-container">
            <div class="logo">SA√â24 Simulation Avanc√©e</div>
            <div class="nav-links" id="navLinks">
                <a href="index.html" class="nav-link">üè† Accueil</a>
                <a href="monitoring.html" class="nav-link">üìä Monitoring</a>
                <a href="#" class="nav-link" style="background: rgba(255,255,255,0.2);">üî• Heatmap</a>
                <a href="trajectory.html" class="nav-link">üéØ Trajectoires</a>
                <a href="comparison.html" class="nav-link">‚öñÔ∏è Comparaison</a>
                <a href="reports.html" class="nav-link">üìä Rapports</a>
                <a href="admin.html" class="nav-link">‚öôÔ∏è Admin</a>
            </div>
            <div class="mobile-menu-toggle" id="mobileMenuToggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main class="container" style="margin-top: 100px;">
        <h2 class="section-title">üî• Heatmap de Couverture</h2>
        <p style="text-align: center; color: #5a6c7d; max-width: 800px; margin: -30px auto 40px auto;">
            Visualisation des zones d'efficacit√© et de port√©e des capteurs. Les zones chaudes (vertes/rouges) indiquent une meilleure d√©tection.
        </p>
        <div class="status-text" style="text-align: center; margin-bottom: 20px; color: #5a6c7d; height: 20px;"></div>

        <div class="controls-container">
            <div class="control-group">
                <label for="sensorType">Type de Donn√©es:</label>
                <select id="sensorType">
                    <option value="ultrason">Pr√©cision Ultrason</option>
                    <option value="sound">Pr√©cision Son</option>
                    <option value="combined">Domination (Bleu=Ultrason, Vert=Son)</option>
                    <option value="real-coverage">Densit√© des Points (Tous)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="resolution">R√©solution:</label>
                <select id="resolution">
                    <option value="20">Basse (Rapide)</option>
                    <option value="40" selected>Moyenne</option>
                    <option value="80">Haute (Lent)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="sourcePower">Puissance Source (pour Son):</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="sourcePower" min="50" max="200" value="100">
                    <span id="powerValue">100</span>
                </div>
            </div>
            <div class="control-group" style="justify-content: flex-end;">
                 <button class="btn btn-primary" id="generateBtn">üîÑ G√©n√©rer Heatmap</button>
            </div>
            <div class="control-group" style="justify-content: flex-end;">
                 <button class="btn btn-secondary" id="animateBtn" style="background-color: #27ae60;">‚ñ∂Ô∏è Animer</button>
            </div>
        </div>

        <div class="visualization-container" style="margin-top: 30px;">
            <div class="heatmap-container">
                <div class="heatmap-title">üîä Heatmap Ultrason / Combin√©e</div>
                <canvas class="heatmap-canvas" id="ultrasonHeatmap"></canvas>
                <div class="legend">
                    <span>Faible</span>
                    <span>Moyenne</span>
                    <span>√âlev√©e</span>
                </div>
            </div>
            
            <div class="heatmap-container">
                <div class="heatmap-title">üîâ Heatmap Son</div>
                <canvas class="heatmap-canvas" id="soundHeatmap"></canvas>
                <div class="legend">
                    <span>Faible</span>
                    <span>Moyenne</span>
                    <span>√âlev√©e</span>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>üìä Statistiques de Couverture (Bas√©es sur les donn√©es r√©elles)</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="coveragePercent">--</div>
                    <div class="stat-label">Couverture Zone (%)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="optimalZone">--</div>
                    <div class="stat-label">Zone Couverte (m¬≤)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="deadZones">--</div>
                    <div class="stat-label">Cellules Vides</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="maxRange">--</div>
                    <div class="stat-label">Port√©e Max (m)</div>
                </div>
            </div>
        </div>
    </main>
    
    <script>
        class CoverageHeatmap {
            constructor() {
                this.roomWidth = 8.0;
                this.roomHeight = 8.0;
                this.sensors = {
                    'A': [0.25, 0.25],
                    'B': [0.25, 7.75],
                    'C': [7.75, 7.75]
                };
                this.speedOfSound = 343.0;
                this.isAnimating = false;
                
                this.initEventListeners();
                this.initCanvases();
                this.generateHeatmap();
            }

            initEventListeners() {
                // Check that elements exist before adding listeners
                const generateBtn = document.getElementById('generateBtn');
                if (generateBtn) {
                    generateBtn.addEventListener('click', () => {
                        this.loadRealData();
                    });
                }

                const animateBtn = document.getElementById('animateBtn');
                if (animateBtn) {
                    animateBtn.addEventListener('click', () => {
                        this.toggleAnimation();
                    });
                }

                const sensorType = document.getElementById('sensorType');
                if (sensorType) {
                    sensorType.addEventListener('change', () => {
                        if (!this.isAnimating) this.generateHeatmap();
                    });
                }

                const resolution = document.getElementById('resolution');
                if (resolution) {
                    resolution.addEventListener('change', () => {
                        if (!this.isAnimating) this.generateHeatmap();
                    });
                }

                const sourcePower = document.getElementById('sourcePower');
                if (sourcePower) {
                    sourcePower.addEventListener('input', (e) => {
                        const powerValue = document.getElementById('powerValue');
                        if (powerValue) {
                            powerValue.textContent = e.target.value;
                        }
                    });
                }
            }

            toggleAnimation() {
                if (this.isAnimating) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            startAnimation() {
                this.isAnimating = true;
                const animateBtn = document.getElementById('animateBtn');
                if (animateBtn) {
                    animateBtn.textContent = '‚è∏Ô∏è Pause';
                }
                
                // Animation: automatic update
                this.animationInterval = setInterval(() => {
                    this.loadRealData();
                }, 3000);
                
                this.updateStatus('Mode Animation activ√© - Mise √† jour automatique');
            }

            stopAnimation() {
                this.isAnimating = false;
                const animateBtn = document.getElementById('animateBtn');
                if (animateBtn) {
                    animateBtn.textContent = '‚ñ∂Ô∏è Animation';
                }
                
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
                
                this.updateStatus('Mode Animation d√©sactiv√©');
            }

            async loadRealData() {
                try {
                    this.updateStatus('Chargement des donn√©es...');
                    
                    // Ensure realData is initialized
                    if (!this.realData) {
                        this.realData = {
                            ultrason: [],
                            sound: []
                        };
                    }
                    
                    const response = await fetch('api_get_positions.php?type=all');
                    if (!response.ok) throw new Error('Erreur r√©seau');
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    // Safe assignment
                    this.realData.ultrason = Array.isArray(data.ultrason) ? data.ultrason : [];
                    this.realData.sound = Array.isArray(data.son) ? data.son : [];
                    
                    console.log(`Donn√©es charg√©es: ${this.realData.ultrason.length} ultrason, ${this.realData.sound.length} son`);
                    
                    this.generateHeatmap();
                    this.updateStatus(`Donn√©es charg√©es: ${this.realData.ultrason.length + this.realData.sound.length} points`);
                    
                } catch (error) {
                    console.error('Erreur lors du chargement des donn√©es:', error);
                    this.updateStatus(`Erreur: ${error.message}`);
                    
                    // Reset data in case of error
                    this.realData = {
                        ultrason: [],
                        sound: []
                    };
                    
                    // Fallback to classic generation
                    this.generateHeatmapClassic();
                }
            }

            updateStatus(message) {
                // Safely update status
                const statusElements = document.querySelectorAll('.status-text');
                statusElements.forEach(el => {
                    if (el) el.textContent = message;
                });
                
                // Also try the element in the header
                const headerStatus = document.querySelector('.header .status-text');
                if (headerStatus) {
                    headerStatus.textContent = message;
                }
                
                // Log status
                console.log('Heatmap Status:', message);
            }

            drawRoom() {
                // Check that contexts exist before drawing
                if (this.ultrasonCtx && this.ultrasonCanvas) {
                    this.drawBaseGrid(this.ultrasonCtx, this.ultrasonCanvas);
                }
                if (this.soundCtx && this.soundCanvas) {
                    this.drawBaseGrid(this.soundCtx, this.soundCanvas);
                }
            }

            drawBaseGrid(ctx, canvas) {
                if (!ctx || !canvas) {
                    console.warn('Contexte ou canvas manquant pour drawBaseGrid');
                    return;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw the grid
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 8; i++) {
                    const x = (i / 8) * canvas.width;
                    const y = (i / 8) * canvas.height;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw sensors
                this.drawSensors(ctx, canvas);
            }

            initCanvases() {
                this.ultrasonCanvas = document.getElementById('ultrasonHeatmap');
                this.soundCanvas = document.getElementById('soundHeatmap');
                this.ultrasonCtx = this.ultrasonCanvas.getContext('2d');
                this.soundCtx = this.soundCanvas.getContext('2d');

                // Adjust canvas sizes
                [this.ultrasonCanvas, this.soundCanvas].forEach(canvas => {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                });
            }

            calculateDistance(point1, point2) {
                return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));
            }

            generateHeatmap() {
                const sensorTypeElement = document.getElementById('sensorType');
                const resolutionElement = document.getElementById('resolution');
                
                const sensorType = sensorTypeElement ? sensorTypeElement.value : 'ultrason';
                const resolution = resolutionElement ? parseInt(resolutionElement.value) : 40;
                
                console.log(`G√©n√©ration heatmap ${resolution}x${resolution} pour type: ${sensorType}`);

                if (sensorType === 'real-coverage') {
                    this.generateRealCoverageHeatmap(resolution);
                } else if (sensorType === 'ultrason') {
                    this.generateDataBasedHeatmap(resolution, 'ultrason');
                } else if (sensorType === 'sound') {
                    this.generateDataBasedHeatmap(resolution, 'sound');
                } else if (sensorType === 'combined') {
                    this.generateCombinedHeatmap(resolution);
                } else {
                    this.generateHeatmapClassic();
                }
                
                this.calculateRealStatistics();
            }

            generateRealCoverageHeatmap(resolution) {
                const canvas = this.ultrasonCanvas;
                const ctx = this.ultrasonCtx;
                
                // Verify that the canvas and context exist
                if (!canvas || !ctx) {
                    console.error('Canvas ultrason non disponible');
                    this.updateStatus('Erreur: Canvas non initialis√©');
                    return;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Verify that the data exists
                if (!this.realData || !this.realData.ultrason || !this.realData.sound) {
                    ctx.fillStyle = '#666';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Donn√©es non disponibles', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;
                
                // Create a density grid based on real positions
                const densityGrid = Array(resolution).fill().map(() => Array(resolution).fill(0));
                
                // Add ultrasound points
                this.realData.ultrason.forEach(point => {
                    const x = parseFloat(point.pos_x_estimee);
                    const y = parseFloat(point.pos_y_estimee);
                    
                    if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                        const gridX = Math.floor((x / this.roomWidth) * resolution);
                        const gridY = Math.floor((y / this.roomHeight) * resolution);
                        
                        if (gridX >= 0 && gridX < resolution && gridY >= 0 && gridY < resolution) {
                            densityGrid[gridY][gridX]++;
                        }
                    }
                });
                
                // Add sound points
                this.realData.sound.forEach(point => {
                    const x = parseFloat(point.pos_x_estimee);
                    const y = parseFloat(point.pos_y_estimee);
                    
                    if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                        const gridX = Math.floor((x / this.roomWidth) * resolution);
                        const gridY = Math.floor((y / this.roomHeight) * resolution);
                        
                        if (gridX >= 0 && gridX < resolution && gridY >= 0 && gridY < resolution) {
                            densityGrid[gridY][gridX] += 0.8; // Slightly different weight
                        }
                    }
                });
                
                // Find the maximum density
                const maxDensity = Math.max(...densityGrid.flat());
                
                if (maxDensity === 0) {
                    // No data, display a message
                    ctx.fillStyle = '#666';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Aucune donn√©e disponible', canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                // Draw the heatmap
                for (let y = 0; y < resolution; y++) {
                    for (let x = 0; x < resolution; x++) {
                        const density = densityGrid[y][x];
                        if (density > 0) {
                            const intensity = density / maxDensity;
                            
                            // Color based on density
                            const hue = 240 - (intensity * 180); // Blue to red
                            const saturation = 80;
                            const lightness = 30 + (intensity * 40);
                            
                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                
                this.drawSensors(ctx, canvas);
            }

            drawSensors(ctx, canvas) {
                if (!ctx || !canvas) {
                    console.warn('Contexte ou canvas manquant pour drawSensors');
                    return;
                }
                
                const sensorColors = { 'A': '#00FFFF', 'B': '#FF00FF', 'C': '#FFFF00' };
                
                Object.entries(this.sensors).forEach(([name, pos]) => {
                    const x = (pos[0] / this.roomWidth) * canvas.width;
                    const y = (pos[1] / this.roomHeight) * canvas.height;
                    
                    // Sensor circle
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.fillStyle = sensorColors[name];
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(name, x, y + 5);
                });
            }

            generateDataBasedHeatmap(resolution, type) {
                const canvas = type === 'ultrason' ? this.ultrasonCanvas : this.soundCanvas;
                const ctx = type === 'ultrason' ? this.ultrasonCtx : this.soundCtx;
                
                // Verify that the canvas and context exist
                if (!canvas || !ctx) {
                    console.error(`Canvas ${type} non disponible`);
                    return;
                }
                
                const data = this.realData[type];
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!data || data.length === 0) {
                    ctx.fillStyle = '#666';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Aucune donn√©e ${type}`, canvas.width / 2, canvas.height / 2);
                    return;
                }
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;
                
                // Analyze the distribution of points and accuracies
                const accuracyGrid = Array(resolution).fill().map(() => Array(resolution).fill([]));
                
                data.forEach(point => {
                    const x = parseFloat(point.pos_x_estimee);
                    const y = parseFloat(point.pos_y_estimee);
                    
                    if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                        const gridX = Math.floor((x / this.roomWidth) * resolution);
                        const gridY = Math.floor((y / this.roomHeight) * resolution);
                        
                        if (gridX >= 0 && gridX < resolution && gridY >= 0 && gridY < resolution) {
                            // Compute a "precision" based on distance coherence
                            const distA = parseFloat(point.dist_a);
                            const distB = parseFloat(point.dist_b);
                            const distC = parseFloat(point.dist_c);
                            
                            // Check coherence (triangulation possible)
                            const coherence = this.calculateCoherence(x, y, distA, distB, distC);
                            accuracyGrid[gridY][gridX].push(coherence);
                        }
                    }
                });
                
                // Draw based on average precision per cell
                for (let y = 0; y < resolution; y++) {
                    for (let x = 0; x < resolution; x++) {
                        const coherences = accuracyGrid[y][x];
                        if (coherences.length > 0) {
                            const avgCoherence = coherences.reduce((a, b) => a + b, 0) / coherences.length;
                            const dataPoints = coherences.length;
                            
                            // Quality based on coherence and number of points
                            const quality = (avgCoherence * 0.7) + (Math.min(dataPoints / 5, 1) * 0.3);
                            
                            const hue = quality * 120; // Red to green
                            const saturation = 70;
                            const lightness = 25 + (quality * 50);
                            
                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                
                this.drawSensors(ctx, canvas);
            }

            calculateDistance(point1, point2) {
                return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));
            }

            calculateCoherence(x, y, distA, distB, distC) {
                // Compute theoretical distances
                const theoreticalA = this.calculateDistance([x, y], this.sensors['A']);
                const theoreticalB = this.calculateDistance([x, y], this.sensors['B']);
                const theoreticalC = this.calculateDistance([x, y], this.sensors['C']);
                
                // Compute relative error
                const errorA = Math.abs(distA - theoreticalA) / Math.max(theoreticalA, 0.1);
                const errorB = Math.abs(distB - theoreticalB) / Math.max(theoreticalB, 0.1);
                const errorC = Math.abs(distC - theoreticalC) / Math.max(theoreticalC, 0.1);
                
                const avgError = (errorA + errorB + errorC) / 3;
                
                // Convert error into a coherence score (0-1)
                return Math.max(0, Math.min(1, 1 - avgError));
            }

            generateUltrasonHeatmap(resolution) {
                const canvas = this.ultrasonCanvas;
                const ctx = this.ultrasonCtx;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;
                const sourcePower = parseInt(document.getElementById('sourcePower').value);

                for (let x = 0; x < resolution; x++) {
                    for (let y = 0; y < resolution; y++) {
                        const realX = (x / resolution) * this.roomWidth;
                        const realY = (y / resolution) * this.roomHeight;
                        
                        // Calculate ultrasound reception quality based on triangulation
                        let triangulationQuality = 0;
                        let visibleSensors = 0;
                        
                        Object.values(this.sensors).forEach(sensorPos => {
                            const distance = this.calculateDistance([realX, realY], sensorPos);
                            
                            // Optimal zone for ultrasound: between 0.5m and 5m
                            if (distance >= 0.5 && distance <= 5.0) {
                                // Quality depends on distance (optimal around 2-3m)
                                const optimalDistance = 2.5;
                                const distanceFromOptimal = Math.abs(distance - optimalDistance);
                                const sensorQuality = Math.max(0, 1 - (distanceFromOptimal / 2.5));
                                
                                // Power factor influences range
                                const powerFactor = sourcePower / 100; // Normalization
                                const adjustedQuality = sensorQuality * powerFactor;
                                
                                triangulationQuality += adjustedQuality;
                                visibleSensors++;
                            }
                        });
                        
                        // Final quality based on number of sensors and their quality
                        let finalQuality = 0;
                        if (visibleSensors >= 3) {
                            finalQuality = triangulationQuality / 3; // Excellent triangulation
                        } else if (visibleSensors === 2) {
                            finalQuality = (triangulationQuality / 2) * 0.6; // Approximate triangulation
                        } else if (visibleSensors === 1) {
                            finalQuality = triangulationQuality * 0.3; // Localization impossible
                        }
                        
                        finalQuality = Math.min(1, finalQuality);
                        
                        // Color based on quality
                        if (finalQuality < 0.1) {
                            // Dead zone (dark red)
                            ctx.fillStyle = '#4a0e0e';
                        } else if (finalQuality < 0.4) {
                            // Weak zone (red to orange)
                            const intensity = (finalQuality - 0.1) / 0.3;
                            const hue = intensity * 30; // 0 (red) to 30 (orange)
                            ctx.fillStyle = `hsl(${hue}, 80%, ${20 + intensity * 30}%)`;
                        } else if (finalQuality < 0.8) {
                            // Acceptable zone (orange to green)
                            const intensity = (finalQuality - 0.4) / 0.4;
                            const hue = 30 + intensity * 60; // 30 (orange) to 90 (green)
                            ctx.fillStyle = `hsl(${hue}, 75%, ${35 + intensity * 25}%)`;
                        } else {
                            // Optimal zone (bright green)
                            const intensity = (finalQuality - 0.8) / 0.2;
                            ctx.fillStyle = `hsl(120, 70%, ${50 + intensity * 20}%)`;
                        }
                        
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
                
                // Dessiner les capteurs
                this.drawSensors(ctx, canvas);
            }

            generateSoundHeatmap(resolution, sourcePower) {
                const canvas = this.soundCanvas;
                const ctx = this.soundCtx;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;

                for (let x = 0; x < resolution; x++) {
                    for (let y = 0; y < resolution; y++) {
                        const realX = (x / resolution) * this.roomWidth;
                        const realY = (y / resolution) * this.roomHeight;
                        
                        // Calculate the average amplitude received by all sensors
                        let totalAmplitude = 0;
                        let validSensors = 0;
                        
                        Object.values(this.sensors).forEach(sensorPos => {
                            const distance = this.calculateDistance([realX, realY], sensorPos);
                            if (distance > 0.1) { // Avoid division by zero
                                const amplitude = sourcePower / (distance * distance);
                                totalAmplitude += amplitude;
                                validSensors++;
                            }
                        });
                        
                        if (validSensors > 0) {
                            const avgAmplitude = totalAmplitude / validSensors;
                            
                            // Normalize amplitude (log scale for better display)
                            const normalizedAmplitude = Math.min(1, Math.log10(avgAmplitude + 1) / 3);
                            
                            // Color based on amplitude
                            const hue = 240 - (normalizedAmplitude * 180); // From purple to red
                            const saturation = 80;
                            const lightness = 20 + (normalizedAmplitude * 60);
                            
                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        } else {
                            ctx.fillStyle = '#000000'; // Dead zone
                        }
                        
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
                
                // Draw sensors
                this.drawSensors(ctx, canvas);
            }

            drawSensors(ctx, canvas) {
                const sensorColors = { 'A': '#00FFFF', 'B': '#FF00FF', 'C': '#FFFF00' };
                
                Object.entries(this.sensors).forEach(([name, pos]) => {
                    const x = (pos[0] / this.roomWidth) * canvas.width;
                    const y = (pos[1] / this.roomHeight) * canvas.height;
                    
                    // Sensor circle
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.fillStyle = sensorColors[name];
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(name, x, y + 5);
                });
            }

            calculateRealStatistics() {
                // Verify that the data exists
                if (!this.realData || !this.realData.ultrason || !this.realData.sound) {
                    // Default values if no data
                    document.getElementById('coveragePercent').textContent = '0%';
                    document.getElementById('optimalZone').textContent = '0';
                    document.getElementById('deadZones').textContent = 'N/A';
                    document.getElementById('maxRange').textContent = '0m';
                    return;
                }
                
                const totalUltrason = this.realData.ultrason.length;
                const totalSound = this.realData.sound.length;
                const totalPoints = totalUltrason + totalSound;
                
                // Calculate covered areas
                const coveredCells = new Set();
                const resolution = 40; // Default resolution for calculation
                
                [...this.realData.ultrason, ...this.realData.sound].forEach(point => {
                    const x = parseFloat(point.pos_x_estimee);
                    const y = parseFloat(point.pos_y_estimee);
                    
                    if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                        const gridX = Math.floor((x / this.roomWidth) * resolution);
                        const gridY = Math.floor((y / this.roomHeight) * resolution);
                        coveredCells.add(`${gridX},${gridY}`);
                    }
                });
                
                const coveragePercent = (coveredCells.size / (resolution * resolution)) * 100;
                const cellArea = (this.roomWidth * this.roomHeight) / (resolution * resolution);
                const coveredArea = coveredCells.size * cellArea;
                
                // Calculate average precision
                let totalAccuracy = 0;
                let validPoints = 0;
                
                [...this.realData.ultrason, ...this.realData.sound].forEach(point => {
                    const coherence = this.calculateCoherence(
                        parseFloat(point.pos_x_estimee),
                        parseFloat(point.pos_y_estimee),
                        parseFloat(point.dist_a),
                        parseFloat(point.dist_b),
                        parseFloat(point.dist_c)
                    );
                    
                    if (!isNaN(coherence)) {
                        totalAccuracy += coherence * 100;
                        validPoints++;
                    }
                });
                
                const avgAccuracy = validPoints > 0 ? totalAccuracy / validPoints : 0;
                
                // Calculate maximum range
                let maxRange = 0;
                [...this.realData.ultrason, ...this.realData.sound].forEach(point => {
                    const distances = [
                        parseFloat(point.dist_a),
                        parseFloat(point.dist_b),
                        parseFloat(point.dist_c)
                    ];
                    const maxDist = Math.max(...distances.filter(d => !isNaN(d)));
                    if (maxDist > maxRange) maxRange = maxDist;
                });
                
                // Safely update the display
                const elements = {
                    'coveragePercent': coveragePercent.toFixed(1) + '%',
                    'optimalZone': coveredArea.toFixed(1),
                    'deadZones': Math.max(0, resolution * resolution - coveredCells.size),
                    'maxRange': maxRange.toFixed(1) + 'm'
                };
                
                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                    }
                });
            }

            generateCombinedHeatmap(resolution) {
                // Verify that the canvases exist
                if (!this.ultrasonCanvas || !this.ultrasonCtx) {
                    console.error('Canvas ultrason non disponible pour la vue combin√©e');
                    return;
                }
                
                // Display the combined heatmap in the ultrasound canvas
                const canvas = this.ultrasonCanvas;
                const ctx = this.ultrasonCtx;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;
                
                // Combined grid
                const combinedGrid = Array(resolution).fill().map(() => Array(resolution).fill({ ultrason: 0, sound: 0 }));
                
                // Add ultrasound data
                if (this.realData && this.realData.ultrason) {
                    this.realData.ultrason.forEach(point => {
                        const x = parseFloat(point.pos_x_estimee);
                        const y = parseFloat(point.pos_y_estimee);
                        
                        if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                            const gridX = Math.floor((x / this.roomWidth) * resolution);
                            const gridY = Math.floor((y / this.roomHeight) * resolution);
                            
                            if (gridX >= 0 && gridX < resolution && gridY >= 0 && gridY < resolution) {
                                combinedGrid[gridY][gridX] = { 
                                    ...combinedGrid[gridY][gridX], 
                                    ultrason: combinedGrid[gridY][gridX].ultrason + 1 
                                };
                            }
                        }
                    });
                }
                
                // Add sound data
                if (this.realData && this.realData.sound) {
                    this.realData.sound.forEach(point => {
                        const x = parseFloat(point.pos_x_estimee);
                        const y = parseFloat(point.pos_y_estimee);
                        
                        if (x >= 0 && x <= this.roomWidth && y >= 0 && y <= this.roomHeight) {
                            const gridX = Math.floor((x / this.roomWidth) * resolution);
                            const gridY = Math.floor((y / this.roomHeight) * resolution);
                            
                            if (gridX >= 0 && gridX < resolution && gridY >= 0 && gridY < resolution) {
                                combinedGrid[gridY][gridX] = { 
                                    ...combinedGrid[gridY][gridX], 
                                    sound: combinedGrid[gridY][gridX].sound + 1 
                                };
                            }
                        }
                    });
                }
                
                // Draw
                for (let y = 0; y < resolution; y++) {
                    for (let x = 0; x < resolution; x++) {
                        const cell = combinedGrid[y][x];
                        const total = cell.ultrason + cell.sound;
                        
                        if (total > 0) {
                            const ultrasonRatio = cell.ultrason / total;
                            
                            // Color mix: blue for ultrasound, green for sound
                            const hue = ultrasonRatio * 240 + (1 - ultrasonRatio) * 120; // Blue to green
                            const saturation = 70;
                            const lightness = 30 + (Math.min(total / 3, 1) * 40);
                            
                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                        }
                    }
                }
                
                this.drawSensors(ctx, canvas);
                
                // Clear the sound canvas to show the legend
                if (this.soundCtx && this.soundCanvas) {
                    const soundCtx = this.soundCtx;
                    soundCtx.clearRect(0, 0, this.soundCanvas.width, this.soundCanvas.height);
                    soundCtx.fillStyle = '#333';
                    soundCtx.font = '16px Arial';
                    soundCtx.textAlign = 'center';
                    soundCtx.fillText('Vue Combin√©e', this.soundCanvas.width / 2, this.soundCanvas.height / 2 - 20);
                    soundCtx.font = '12px Arial';
                    soundCtx.fillStyle = '#3498db';
                    soundCtx.fillText('üî∑ Ultrason dominant', this.soundCanvas.width / 2, this.soundCanvas.height / 2 + 10);
                    soundCtx.fillStyle = '#27ae60';
                    soundCtx.fillText('üü¢ Son dominant', this.soundCanvas.width / 2, this.soundCanvas.height / 2 + 30);
                }
            }

            generateHeatmapClassic() {
                // Fallback: generate a classic theoretical heatmap
                const resolutionElement = document.getElementById('resolution');
                const sourcePowerElement = document.getElementById('sourcePower');
                
                const resolution = resolutionElement ? parseInt(resolutionElement.value) : 40;
                const sourcePower = sourcePowerElement ? parseInt(sourcePowerElement.value) : 100;
                
                // Generate classic heatmaps for both types
                this.generateUltrasonHeatmap(resolution);
                this.generateSoundHeatmap(resolution, sourcePower);
            }

            generateUltrasonHeatmap(resolution) {
                const canvas = this.ultrasonCanvas;
                const ctx = this.ultrasonCtx;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;
                const sourcePower = 100; // Default value

                for (let x = 0; x < resolution; x++) {
                    for (let y = 0; y < resolution; y++) {
                        const realX = (x / resolution) * this.roomWidth;
                        const realY = (y / resolution) * this.roomHeight;
                        
                        // Calculate ultrasound reception quality based on triangulation
                        let triangulationQuality = 0;
                        let visibleSensors = 0;
                        
                        Object.values(this.sensors).forEach(sensorPos => {
                            const distance = this.calculateDistance([realX, realY], sensorPos);
                            
                            // Optimal zone for ultrasound: between 0.5m and 5m
                            if (distance >= 0.5 && distance <= 5.0) {
                                const optimalDistance = 2.5;
                                const distanceFromOptimal = Math.abs(distance - optimalDistance);
                                const sensorQuality = Math.max(0, 1 - (distanceFromOptimal / 2.5));
                                
                                const powerFactor = sourcePower / 100;
                                const adjustedQuality = sensorQuality * powerFactor;
                                
                                triangulationQuality += adjustedQuality;
                                visibleSensors++;
                            }
                        });
                        
                        // Final quality
                        let finalQuality = 0;
                        if (visibleSensors >= 3) {
                            finalQuality = triangulationQuality / 3;
                        } else if (visibleSensors === 2) {
                            finalQuality = (triangulationQuality / 2) * 0.6;
                        } else if (visibleSensors === 1) {
                            finalQuality = triangulationQuality * 0.3;
                        }
                        
                        finalQuality = Math.min(1, finalQuality);
                        
                        // Color based on quality
                        if (finalQuality < 0.1) {
                            ctx.fillStyle = '#4a0e0e';
                        } else if (finalQuality < 0.4) {
                            const intensity = (finalQuality - 0.1) / 0.3;
                            const hue = intensity * 30;
                            ctx.fillStyle = `hsl(${hue}, 80%, ${20 + intensity * 30}%)`;
                        } else if (finalQuality < 0.8) {
                            const intensity = (finalQuality - 0.4) / 0.4;
                            const hue = 30 + intensity * 60;
                            ctx.fillStyle = `hsl(${hue}, 75%, ${35 + intensity * 25}%)`;
                        } else {
                            const intensity = (finalQuality - 0.8) / 0.2;
                            ctx.fillStyle = `hsl(120, 70%, ${50 + intensity * 20}%)`;
                        }
                        
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
                
                this.drawSensors(ctx, canvas);
            }

            generateSoundHeatmap(resolution, sourcePower) {
                const canvas = this.soundCanvas;
                const ctx = this.soundCtx;
                
                if (!canvas || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const cellWidth = canvas.width / resolution;
                const cellHeight = canvas.height / resolution;

                for (let x = 0; x < resolution; x++) {
                    for (let y = 0; y < resolution; y++) {
                        const realX = (x / resolution) * this.roomWidth;
                        const realY = (y / resolution) * this.roomHeight;
                        
                        let totalAmplitude = 0;
                        let validSensors = 0;
                        
                        Object.values(this.sensors).forEach(sensorPos => {
                            const distance = this.calculateDistance([realX, realY], sensorPos);
                            if (distance > 0.1) {
                                const amplitude = sourcePower / (distance * distance);
                                totalAmplitude += amplitude;
                                validSensors++;
                            }
                        });
                        
                        if (validSensors > 0) {
                            const avgAmplitude = totalAmplitude / validSensors;
                            const normalizedAmplitude = Math.min(1, Math.log10(avgAmplitude + 1) / 3);
                            
                            const hue = 240 - (normalizedAmplitude * 180);
                            const saturation = 80;
                            const lightness = 20 + (normalizedAmplitude * 60);
                            
                            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        } else {
                            ctx.fillStyle = '#000000';
                        }
                        
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
                
                this.drawSensors(ctx, canvas);
            }

            toggleAnimation() {
                const btn = document.getElementById('animateBtn');
                
                if (this.isAnimating) {
                    this.isAnimating = false;
                    btn.textContent = '‚ñ∂Ô∏è Animation';
                    clearInterval(this.animationInterval);
                } else {
                    this.isAnimating = true;
                    btn.textContent = '‚è∏Ô∏è Pause';
                    
                    let frame = 0;
                    this.animationInterval = setInterval(() => {
                        // Animation: vary the source power
                        const basePower = parseInt(document.getElementById('sourcePower').value);
                        const animatedPower = basePower + Math.sin(frame * 0.1) * 20;
                        
                        this.generateSoundHeatmap(
                            parseInt(document.getElementById('resolution').value), 
                            animatedPower
                        );
                        
                        frame++;
                    }, 100);
                }
            }
        }

        // Initialization
        window.addEventListener('load', () => {
            console.log('DOM charg√©, initialisation de la Heatmap...');
            try {
                new CoverageHeatmap();
            } catch (error) {
                console.error('Erreur lors de l\'initialisation de la Heatmap:', error);
            }
        });
    </script>
</body>
</html>